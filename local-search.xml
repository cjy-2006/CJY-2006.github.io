<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/29/%E8%A1%A8%E8%BE%BE%E5%BC%8F.10.28/"/>
    <url>/2025/10/29/%E8%A1%A8%E8%BE%BE%E5%BC%8F.10.28/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>表达式有运算符、常量及变量构成。每一个表达式，都有一个对应的值。该值与表达式中操作符和优先级有关</p><h2 id="常见表达式和表达式求值"><a href="#常见表达式和表达式求值" class="headerlink" title="常见表达式和表达式求值"></a>常见表达式和表达式求值</h2><ol><li><p>赋值表达式，左值即为表达式的值，例如a&#x3D;10;整个表达式就是a的值 </p></li><li><p>逗号表达式：a,b,c,d,e,f从左往右算，最右边的部分f就是整个表达式的值，优先级是最低的</p></li></ol><p>​     例如a&#x3D; 3*5,a *4应该先算a&#x3D;3 * 5&#x3D;15 再算a * 4 最后值为a * 4&#x3D;60</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,\n&quot;</span>, (a = <span class="hljs-number">3</span> * <span class="hljs-number">5</span>, a * <span class="hljs-number">4</span>));<span class="hljs-comment">//在逗号运算符上加括号是防止被认为是函数参数分隔符</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:%d,\n&quot;</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出位60，a：15</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;   <br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> a = b = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,\n&quot;</span>, (c = a++, b++, ++b));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个将a++赋值给c，先赋值再加一，因此c还是1，逗号运算符的·值是最右边的，b++，此时b&#x3D;2，最后值为++b&#x3D;3</p><ol start="3"><li><p>逻辑板表达式</p><p>逻辑与：a&amp;&amp;b&amp;&amp;！c，先算！c在进行&amp;&amp;的运算，出现false即停止</p><p>逻辑或：a||b||！c和逻辑与差不多，但是是进行逻辑或运算时出行true即停止</p></li><li><p>比较a&gt;b</p><p>a&lt;b</p><p>a&#x3D;&#x3D;b</p><p>fabs(x)&lt;&#x3D;1e-6单精度浮点数的正负判断</p><p>输出的也是布尔值  </p></li><li><p>三目表达式</p></li></ol><p>​       比较两个数的大小+</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tchar.h&gt;</span></span><br><span class="hljs-type">int</span>  <span class="hljs-title function_">get_max</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d)</span>  <span class="hljs-comment">//get_max函数定义是取两个参数中的最大值</span><br><span class="hljs-comment">// 自定义函数：求两个整数的最大值</span><br><span class="hljs-comment">// 参数：c和d为待比较的整数</span><br><span class="hljs-comment">// 返回值：返回c和d中较大的那个（若相等则返回其中一个）</span><br>&#123;<br><span class="hljs-keyword">return</span> c &gt; d ? c : d;<br>&#125;<br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br><span class="hljs-comment">// Windows平台扩展的程序入口函数：_tmain</span><br><span class="hljs-comment">// 作用类似标准C的main函数，但用于适配字符集：</span><br><span class="hljs-comment">// - 当编译选项为&quot;多字节字符集&quot;时，_tmain会被替换为main，_TCHAR会被替换为char</span><br><span class="hljs-comment">// - 当编译选项为&quot;Unicode字符集&quot;时，_tmain会被替换为wmain，_TCHAR会被替换为wchar_t（宽字符类型）</span><br><span class="hljs-comment">// 参数说明：</span><br><span class="hljs-comment">//   argc：命令行参数的个数（包含程序名本身）</span><br><span class="hljs-comment">//   argv：指向参数数组的指针，每个元素为_TCHAR类型（根据字符集选项决定是char还是wchar_t）</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max:%d\n&quot;</span>,get_max(<span class="hljs-number">5</span>,<span class="hljs-number">7</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比较三个数的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tchar.h&gt;</span></span><br><span class="hljs-type">int</span>  <span class="hljs-title function_">get_max</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d,<span class="hljs-type">int</span> e)</span>  <span class="hljs-comment">//get_max函数定义是取两个参数中的最大值</span><br>&#123;<br><span class="hljs-keyword">return</span> (c &gt; d ? c : d)&gt;e?(c&gt;d?c:d):e;<br>&#125;<br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max:%d\n&quot;</span>, get_max(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>, <span class="hljs-number">7</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先判断(c &gt; d ? c : d)&gt;e的值是真还是假 </p><p>如果为真就输出cd之间较大的那个</p><p>判断一年是否为闰年</p><p>闰年条件： </p><ol><li><strong>普通闰年</strong>：年份是 4 的倍数，且不是 100 的倍数。<ul><li>示例：2020 年，2020÷4&#x3D;505（是 4 的倍数），2020÷100&#x3D;20.2（不是 100 的倍数），因此 2020 年是闰年。</li></ul></li><li><strong>世纪闰年</strong>：年份是 400 的倍数（世纪年指末尾有两个 0 的年份，如 1900 年、2000 年）。<ul><li>示例：2000 年，2000÷400&#x3D;5（是 400 的倍数），因此 2000 年是闰年；1900 年，1900÷400&#x3D;4.75（不是 400 的倍数），因此 1900 年不是闰年。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tchar.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span>  <span class="hljs-comment">// 包含bool类型的头文件</span></span><br><br><span class="hljs-comment">// 修正注释：取三个参数中的最大值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_max</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> e)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (c &gt; d ? c : d) &gt; e ? (c &gt; d ? c : d) : e;<br>&#125;<br><br><span class="hljs-comment">// 判断闰年的函数（逻辑正确，保留）</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">is_a_leap_year</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br>    <span class="hljs-comment">// 规则：能被4整除，且不能被100整除，或者能被400整除</span><br>    <span class="hljs-keyword">return</span> (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span> || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> _tmain(<span class="hljs-type">int</span> argc, _TCHAR* argv[])<br>&#123;<br>    <span class="hljs-comment">// 测试求最大值功能</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max:%d\n&quot;</span>, get_max(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>));  <span class="hljs-comment">// 输出：7</span><br><br>    <span class="hljs-comment">// 闰年判断功能（添加用户输入逻辑）</span><br>    <span class="hljs-type">int</span> year = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input a year:\n&quot;</span>);<br>    scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;year);  <span class="hljs-comment">// 读取用户输入的年份</span><br>    <span class="hljs-comment">// 打印结果（使用输入的year判断）</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;year %d %s a leap year \n&quot;</span>,<br>        year, is_a_leap_year(year) ? <span class="hljs-string">&quot;is&quot;</span> : <span class="hljs-string">&quot;is not&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure><p>也可以将 return (year % 4 &#x3D;&#x3D; 0) &amp;&amp; (year % 100 !&#x3D; 0 || year % 400 &#x3D;&#x3D; 0);优化为</p><p>return( year%(year%100?4:400)?false:true)</p><p>先算(year%100?4:400)若year可以被100整除则year%100&#x3D;0是假值，该表达式的值就是400，year再%400，再判断是不是世纪闰年</p><p>若不能被100整除，(year%100?4:400)的值就是4，来判断是不是普通闰年</p><p>a+++b与贪心算法</p><p>贪心算法</p><p>编译器将程序分解成符号的方法是：从左到右一个字符一个字符的读入，如果该字符可能组成一个符号就读如下一个字符，判断已经读入的两个字符能否可能是一个符号的组成部分，如果可能就继续读入下一字符，重复以上判断知道不能组成一个有意义的符号</p><p>因此a+++b应当作为（a++）+b处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> c = a+++ b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,a,b,c);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可读性低，不建议使用</p><p>作业</p><ol><li><p>单独成句时没区别结果都是i+1</p><p>在赋值语句中   i++，先赋值，i再加一，++i先将i加一，再赋值</p></li><li><p>a&#x3D;2，b&#x3D;3，c&#x3D;1表达式的值为3</p></li><li><p>9,10,9,10</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the max number is:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a &gt; b ? a : b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/28/10.27/"/>
    <url>/2025/10/28/10.27/</url>
    
    <content type="html"><![CDATA[<p>-–</p><p>title: 十月二十七日日志</p><p>date: 2025-10-27</p><p>tags:</p><p>-–</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="1-运算符中被操做的变量或常量树木叫操作数"><a href="#1-运算符中被操做的变量或常量树木叫操作数" class="headerlink" title="1.运算符中被操做的变量或常量树木叫操作数"></a>1.运算符中被操做的变量或常量树木叫操作数</h3><p>一个操作数的运算符叫单目运算符，以此内推，最多为三目运算符</p><p>例如</p><p>单目：&amp;  ++ ！ ~   sizeof</p><p>双目：+——&amp;&#x2F;</p><p>三目运算符：？</p><h2 id="2结合律：解决-“同一级别的运算符谁先算”-的规则，与优先级共同决定了表达式的运算顺序。先按照优先级来写，如果优先级一样就按照结合律来运算"><a href="#2结合律：解决-“同一级别的运算符谁先算”-的规则，与优先级共同决定了表达式的运算顺序。先按照优先级来写，如果优先级一样就按照结合律来运算" class="headerlink" title="2结合律：解决 “同一级别的运算符谁先算” 的规则，与优先级共同决定了表达式的运算顺序。先按照优先级来写，如果优先级一样就按照结合律来运算"></a><strong>2结合律：解决 “同一级别的运算符谁先算” 的规则，与优先级共同决定了表达式的运算顺序。先按照优先级来写，如果优先级一样就按照结合律来运算</strong></h2><p>从右往左：单目运算符</p><p>​三目运算符例a?b:c?d:e   正常运算：a?b:(c?d:e)</p><p>​                  赋值运算符  &#x3D;          </p><p>​                复合运算符    +&#x3D;  -&#x3D;</p><p>​               逗号运算符     ，</p><p>除了这五种以外都是从左往右</p><h1 id="目前应该掌握的运算符"><a href="#目前应该掌握的运算符" class="headerlink" title="目前应该掌握的运算符"></a>目前应该掌握的运算符</h1><p><strong>1.（）：用于改变优先级和结合律，不确定运算符优先级和结合律时用（）准确表达自己的意思，因为（）的优先级是最高的</strong></p><p><strong>2.逻辑非运算符：！将true改为False，即将0（false）改为1,对于非0用逻辑非则变为真</strong></p><p><strong>3.自增，自减：i++        ++i        i–        –i</strong></p><p><em>i++和++i的区别,二者都是i+1的意思</em></p><p><em>一：在c语言的内建型别，此时i是一个内建型别</em></p><p><em>i++    :</em> </p><p><em>++i    :</em></p><p><em>在c++中，i是一个对象，++I是一个对象，其效率高于i++高</em></p><p><em>二’在符合表达式或者赋值语句里</em></p><p>** </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> a =i++ <span class="hljs-comment">//先执行a =i在执行i =i+1       a ==0,i==1</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> b =++i<span class="hljs-comment">//先执行i =i+1;b =i     b==1 , i==1</span><br><br><br><br> <br></code></pre></td></tr></table></figure><p> <em>三，函数中</em></p><p><em><strong>使用场景区别</strong>：</em></p><ul><li><em>单独使用时（如<code>i++;</code>或<code>++i;</code>），两者效果完全相同</em></li><li><em>在表达式中使用时，需要根据是否需要当前值还是新值来选择</em></li><li><em>在函数传参是的特点</em></li></ul><p><strong>4.正负：+   -</strong></p><p><strong>5.强转运算：（int）3.14f，将3.14f转换为整数</strong></p><p><strong>6.sizeof用于计算类型，变量，常量的长度(单位为字节)</strong></p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a= <span class="hljs-number">10</span>;<br>siaeof(<span class="hljs-type">int</span>)或<span class="hljs-keyword">sizeof</span>(a)<br></code></pre></td></tr></table></figure><p>用sizeof计算长度是要加括号</p><p><strong>7.取址符：&amp;加在变量前面就能获取变量地址</strong></p><p><em><em>8.算数运算符</em> &#x2F; % (取余)       高优先级</em>*</p><p>​                       <strong>+  -                    低优先级</strong></p><h4 id="9-比较运算符"><a href="#9-比较运算符" class="headerlink" title="9.比较运算符&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D; ，&#x3D;&#x3D;， !&#x3D;(不等于)"></a>9.比较运算符&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D; ，&#x3D;&#x3D;， !&#x3D;(不等于)</h4><p> 一.  若想表示a&gt;b&gt;c，在c语言中应如是a&gt;b&amp;&amp;b&gt;c  &amp;&amp;表示并且</p><p>   单个”&#x3D;“是赋值，因此&#x3D;&#x3D;才是等于</p><p>​例如  你想表达在a 等于1时输出ok，则正确结果如下</p><p>{</p><p>if (a&#x3D;&#x3D;1);</p><p>printf(“ok”)</p><p>}</p><p>​但如果少打一个&#x3D;，就变成把1，赋值给a，c语言中唯一假值是0，除0以外都是真值，1是真值，因此会执行下面的printf命令，从而与真是想法大相径庭</p><p>​为了避免以上错误也可以将a&#x3D;&#x3D;1，改为1&#x3D;&#x3D;a，因为1是常量，无法改变，此时如果编译就会报错以免造成严重后果</p><p>​     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>==a);<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ok\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：此时的代码依旧可以运行因为if后面加了分号，在 C 语言中，<code>if(条件)</code>后面需要跟随 “一条语句”（可以是单个语句，也可以是用<code>{}</code>包裹的复合语句）。</p><p>但你的代码中，<code>if(1==a);</code> 后面直接加了一个分号<code>;</code>—— 这个分号本身构成了一条 “空语句”（即什么都不做的语句）。这意味着：</p><p><code>if</code>语句的 “主体” 就是这个空语句，无论<code>1==a</code>的条件是否成立（这里<code>a=5</code>，条件为假），<code>if</code>都只会执行这个空语句（相当于啥也没干）。</p><p>而后面的<code>{ printf(&quot;b\n&quot;); }</code> 是一个独立的复合语句（和<code>if</code>没有任何关联）。在 C 语言中，用<code>{}</code>包裹的代码块本身就是一条可执行的复合语句，会被无条件执行。</p><p>因此，无论<code>if</code>的条件是否满足，<code>printf(&quot;b\n&quot;);</code>都会被执行，最终打印出<code>b</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>==a)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ok\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就可以正常的不打印”ok”了</p><p>二.浮点数与0进行比较</p><p>因为浮点数有一定误差，存储的只是一个近似值，在经过计算后会产生误差，如预期值是0，但实际是一个近似于0的小数，因此不能用&#x3D;&#x3D;直接和0进行比较</p><h3 id="正确的比较方式：与-“极小阈值”-比较"><a href="#正确的比较方式：与-“极小阈值”-比较" class="headerlink" title="正确的比较方式：与 “极小阈值” 比较"></a>正确的比较方式：与 “极小阈值” 比较</h3><p>判断一个浮点数是否 “接近 0”，应通过比较其<strong>绝对值是否小于一个极小的阈值（epsilon）</strong>。</p><p>阈值的选择需根据浮点数类型的精度决定（精度越高，阈值越小）：</p><ul><li><p><code>float</code>（单精度）：通常用 <code>1e-6</code>（百万分之一）这是e的-6次方</p></li><li><p><code>double</code>（双精度）：通常用 <code>1e-15</code>（千万亿分之一）同理也是e的-15次方</p><p>（也可使用标准库中定义的</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">FLT_EPSILON</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">DBL_EPSILON</span><br></code></pre></td></tr></table></figure><p>，需包含</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;<span class="hljs-built_in">float</span>.h&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">float</span> x = <span class="hljs-number">3.14f</span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-comment">//if(a&lt;=6.5)</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x)&lt;=<span class="hljs-number">1e-6</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not 0\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>1.&amp;&amp;：逻辑与，a&amp;&amp;b 只有a&#x3D;b&#x3D;1表达式的值才为true，否则是false，优先级高于逻辑与</p><p>   b1&amp;&amp;b2&amp;&amp;b3&amp;&amp;b4在运算此语句时；若在b2&amp;&amp;b3时值为false，则整个为false，不用再计算后面的</p><p>2.||：逻辑或：有一个是1则则值为true，优先级低于逻辑与</p><p>​    b1||b2||b3||b4，如果有一个为true则一整个就是true不用再进行计算</p><p>3.！逻辑非，值也是true或者false优先级是逻辑运算符中最高的</p><p>优先级：！&gt;&amp;&amp;&gt;||</p><p>例如：计算</p><p>Int a&#x3D;0 b &#x3D;1 c &#x3D;-1 d&#x3D;0</p><p>a&amp;&amp;b||c&amp;&amp;!d</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">-1</span>, d = <span class="hljs-number">0</span>;<br>        a &amp;&amp; b || c &amp;&amp;!d;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a &amp;&amp; b || c &amp;&amp;!d);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>计算 <code>!d</code>：</p><p><code>d = 0</code>，逻辑非运算 <code>!0</code> 结果为 <strong>1</strong>（C 语言中，非 0 值表示 “真”，0 表示 “假”）。</p></li><li><p>计算 <code>a &amp;&amp; b</code>：</p><p><code>a = 0</code>（假），<code>b = 1</code>（真）。逻辑与运算中，只要有一个为假，结果就为假，因此 <code>0 &amp;&amp; 1</code> 结果为 <strong>0</strong>。</p></li><li><p>计算 <code>c &amp;&amp; !d</code>：</p><p><code>c = -1</code>（非 0，视为真），<code>!d = 1</code>（真）。逻辑与运算中，两者都为真时结果为真，因此 <code>-1 &amp;&amp; 1</code> 结果为 <strong>1</strong>。</p></li><li><p>计算 <code>(a &amp;&amp; b) || (c &amp;&amp; !d)</code>：</p><p>左边结果为 <code>0</code>（假），右边结果为 <code>1</code>（真）。逻辑或运算中，只要有一个为真，结果就为真，因此 <code>0 || 1</code> 结果为 <strong>1</strong>。</p></li></ol><p>程序运行后，输出结果为：1</p><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>？：条件表达式 ? 表达式1 : 表达式2</p><p>条件表达式确定布尔值，true或false，若为true则结果输出表达式1，若为false则输出表达式2</p><p>表达式 1 和表达式 2 的类型可以不同，但结果会进行<strong>隐式类型转换</strong>（遵循 C 语言类型转换规则）</p><h3 id="复合运算符"><a href="#复合运算符" class="headerlink" title="复合运算符"></a>复合运算符</h3><p>+&#x3D;，-&#x3D; ，*&#x3D;，&#x2F;&#x3D;,%&#x3D;运算法则与Python一样</p><p>a+&#x3D;1 就是a &#x3D;a+1</p><p>逗号运算符</p><p>用于 是一种特殊的运算符，用于将多个表达式 “串联” 成一个表达式，其核心特点是<strong>按顺序执行多个操作，并返回最后一个表达式的结果</strong>。</p><h2 id="优先级记忆口诀"><a href="#优先级记忆口诀" class="headerlink" title="优先级记忆口诀"></a>优先级记忆口诀</h2><p><img src="/images/%E5%8F%A3%E8%AF%80.png" alt="口诀"></p><p>建：箭头_&gt;<img src="/images/%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E5%BE%8B.png" alt="优先级和结合律"></p><p>易：移位运算符</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p><img src="/images/%E4%BD%9C%E4%B8%9A10.28.png" alt="作业10.28"></p><p>1.代码1,2和3,4都是2和4更保险一点，可以有效防止忘记打代码&#x3D;而造成的bug  ,0是常量，不可以改变值，因此如果忘记打&#x3D;会报错</p><p>2.a%&#x3D;5即a &#x3D; a%5</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/27/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2025/10/27/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>-–</p><p>title: 十月二十七日日志</p><p>date: 2025-10-27</p><p>tags:</p><p>-–</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>1.运算符中被操做的变量或常量树木叫操作数</p><p>一个操作数的运算符叫单目运算符，以此内推，最多为三目运算符</p><p>例如</p><p>单目：&amp;  ++ ！ ~   sizeof</p><p>双目：+——&amp;&#x2F;</p><p>三目运算符：？</p><p>2.优先级：解决 “同一级别的运算符谁先算” 的规则，与优先级共同决定了表达式的运算顺序。</p><p>目前应该掌握的运算符</p><p>1.，（）：用于改变优先级和结合律，不确定运算符优先级和结合律时用（）准确表达自己的意思，因为（）的优先级是最高的</p><p>2.逻辑非运算符：！将true改为False，即将0（false）改为1,对于非0用逻辑非则变为真</p><p>3.自增，自减：i++        ++i        i–        –i</p><p>4.正负：+   -</p><p>5.强转运算：（int）3.14f，将3.14f转换为整数</p><p>6.sizeof用于计算类型，变量，常量的长度(单位为字节)</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a= <span class="hljs-number">10</span>;<br>siaeof(<span class="hljs-type">int</span>)或<span class="hljs-keyword">sizeof</span>(a)<br></code></pre></td></tr></table></figure><p>用sizeof计算长度是要加括号</p><p>7.取址符：&amp;加在变量前面就能获取变量地址</p><p>8.算数运算符* &#x2F; % (取余)       高优先级</p><p>​                       +  -                    低优先级</p><p>9.比较运算符&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D; ，&#x3D;&#x3D;， !&#x3D;(不等于)</p><p>若想表示a&gt;b&gt;c，在c语言中应如是a&gt;b&amp;&amp;b&gt;c  &amp;&amp;表示并且</p><p>单个”&#x3D;“是赋值，因此&#x3D;&#x3D;才是等于</p><p>例如  你想表达在a 等于1时输出ok，则正确结果如下</p><p>{</p><p>if (a&#x3D;&#x3D;1);</p><p>printf(“ok”)</p><p>}</p><p>但如果少打一个&#x3D;，就变成把1，赋值给a，c语言中唯一假值是0，除0以外都是真值，1是真值，因此会执行下面的printf命令，从而与真是想法大相径庭</p><p>为了避免以上错误也可以将a&#x3D;&#x3D;1，改为1&#x3D;&#x3D;a，因为1是常量，无法改变，此时如果编译就会报错</p><p>i++和++i的区别,二者都是i+1的意思</p><p>一：在c语言的内建型别，此时i是一个内建型别</p><p>i++    : </p><p>++i    :</p><p>在c++中，i是一个对象，++I是一个对象，其效率高于i++高</p><p>二’在符合表达式或者赋值语句里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> a =i++ <span class="hljs-comment">//先执行a =i在执行i =i+1       a ==0,i==1</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> b =++i<span class="hljs-comment">//先执行i =i+1;b =i     b==1 , i==1</span><br><br><br><br> <br></code></pre></td></tr></table></figure><p> 三，函数中</p><p><strong>使用场景区别</strong>：</p><ul><li>单独使用时（如<code>i++;</code>或<code>++i;</code>），两者效果完全相同</li><li>在表达式中使用时，需要根据是否需要当前值还是新值来选择</li><li>在函数传参是的特点</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/26/10.26/"/>
    <url>/2025/10/26/10.26/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-10-26"><a href="#title-10-26" class="headerlink" title="title :10.26"></a>title :10.26</h2><p>date :10.26</p><hr><h1 id="输入输出—stdio"><a href="#输入输出—stdio" class="headerlink" title="输入输出—stdio"></a>输入输出—stdio</h1><h2 id="1-标准输入输出"><a href="#1-标准输入输出" class="headerlink" title="1.标准输入输出"></a>1.标准输入输出</h2><p>1.字符</p><p>把视频中的代码复制到VS2018后无法运行，只会爆出4996的警告即使是自己将视频中的代码敲下来也不能运行，在视频中4996报错并不影响运行，在VS2018中连编译都不成功</p><p>输入数据长于接受数据缓存就会溢出</p><p>警告4996代表所用函数有严重的安全警告，极其容易引起bug</p><p>输入数据长于接受数据缓存就会溢出</p><p>输入字符，也可不用scanf,也可用getch()(按下字符不用按回车键即可输入，输入字符不在屏幕上显示);和getchar()（要按回车键，会显示输入的字符）,l两个函数并不包含在标准头文件中，在&lt;conio.h&gt;头文件中</p><p>补充：getch也会出发4996，且一样不能运行，改为_getch后问题解决</p><p>scanf 改为scanf_s , 加上长度&lt;”%c”,&amp;c&gt;即可避免该类型报错，scanf_s是只能用于windows,不能用于linux0</p><p> <strong>缓冲区溢出（最常见的隐患）</strong></p><p>当使用 <code>%s</code> 格式符读取字符串时，<code>scanf</code> 会持续读取输入直到遇到空白字符（空格、回车等），且<strong>不会检查目标缓冲区的大小</strong>。如果输入的字符串长度超过缓冲区的容量，多余的数据会覆盖相邻的内存空间，导致：</p><ul><li>程序崩溃（覆盖了函数返回地址等关键数据）；</li><li>敏感数据泄露或被篡改；</li><li>被攻击者利用执行恶意代码（通过覆盖栈上的返回地址，跳转到恶意指令）。</li></ul><h2 id="2-输入输出整数"><a href="#2-输入输出整数" class="headerlink" title="2.输入输出整数"></a>2.输入输出整数</h2><ol><li><p>输入：只有在调用scanf_s时要加上取址符，表示要将整数输入到s所在的地址，对于整数不用加上长度</p><pre><code class="hljs">2. 输出：输出时可用printf来改变其格式：例如以十六进制输出printf(&quot;%#x\n&quot;,100)；此时输出值为0x64       若要打印大写则将小写x改为大写X若想打印指定位数就将’#‘替换为’0n‘(n是你想要的位数)</code></pre></li></ol><p> 3.若想输入64位整数，要先对其进行定义如__int64 变量名 &#x3D;100I64 </p><p>格式为printf(“%I64d\n”)</p><h6 id="printf的格式说明符"><a href="#printf的格式说明符" class="headerlink" title="printf的格式说明符"></a>printf的格式说明符</h6><p>整数</p><table><thead><tr><th>格式符</th><th>含义（输出时）</th><th>输入时作用</th><th>示例（输出）</th></tr></thead><tbody><tr><td><code>%d</code></td><td>十进制有符号整数（<code>int</code>）</td><td>读取十进制有符号整数</td><td><code>printf(&quot;%d&quot;, 123);</code> → <code>123</code></td></tr><tr><td><code>%i</code></td><td>十进制有符号整数（与<code>%d</code>功能相同）</td><td>读取整数（支持八进制前缀<code>0</code>、十六进制前缀<code>0x</code>）</td><td><code>scanf(&quot;%i&quot;, &amp;a);</code> 输入<code>014</code> → 12（八进制转十进制）</td></tr><tr><td><code>%o</code></td><td>八进制无符号整数（无前缀<code>0</code>）</td><td>读取八进制整数（忽略前缀<code>0</code>）</td><td><code>printf(&quot;%o&quot;, 10);</code> → <code>12</code></td></tr><tr><td><code>%x</code></td><td>十六进制无符号整数（小写字母<code>a-f</code>）</td><td>读取十六进制整数（忽略前缀<code>0x</code>）</td><td><code>printf(&quot;%x&quot;, 255);</code> → <code>ff</code></td></tr><tr><td><code>%X</code></td><td>十六进制无符号整数（大写字母<code>A-F</code>）</td><td>同上</td><td><code>printf(&quot;%X&quot;, 255);</code> → <code>FF</code></td></tr><tr><td><code>%u</code></td><td>十进制无符号整数（<code>unsigned int</code>）</td><td>读取十进制无符号整数</td><td><code>printf(&quot;%u&quot;, -1);</code> → 4294967295（无符号溢出结果）</td></tr></tbody></table><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数&#x2F;双精度类型（用于输出输入小数）</p><p>​       </p><table><thead><tr><th>格式符</th><th>含义（输出时）</th><th>输入时作用</th><th>示例（输出）</th></tr></thead><tbody><tr><td><code>%f</code></td><td>十进制浮点数（默认 6 位小数，<code>double</code>）</td><td>读取浮点数（支持小数、指数形式）</td><td><code>printf(&quot;%f&quot;, 3.14);</code> → <code>3.140000</code></td></tr><tr><td><code>%e</code></td><td>科学计数法（小写<code>e</code>，如<code>1.23e+04</code>）</td><td>同上</td><td><code>printf(&quot;%e&quot;, 12300);</code> → <code>1.230000e+04</code></td></tr><tr><td><code>%E</code></td><td>科学计数法（大写<code>E</code>，如<code>1.23E+04</code>）</td><td>同上</td><td><code>printf(&quot;%E&quot;, 12300);</code> → <code>1.230000E+04</code></td></tr><tr><td><code>%g</code></td><td>自动选择<code>%f</code>或<code>%e</code>（取较短格式，去掉多余 0）</td><td>同上</td><td><code>printf(&quot;%g&quot;, 12300.0);</code> → <code>12300</code></td></tr><tr><td><code>%G</code></td><td>自动选择<code>%f</code>或<code>%E</code>（规则同<code>%g</code>）</td><td>同上</td><td><code>printf(&quot;%G&quot;, 0.000123);</code> → <code>1.23E-04</code></td></tr><tr><td><code>%a</code></td><td>十六进制浮点数（小写<code>p</code>，C99+）</td><td>-</td><td><code>printf(&quot;%a&quot;, 3.14);</code> → <code>0x1.91eb85p+1</code></td></tr><tr><td><code>%A</code></td><td>十六进制浮点数（大写<code>P</code>，C99+）</td><td>-</td><td><code>printf(&quot;%A&quot;, 3.14);</code> → <code>0X1.91EB85P+1</code></td></tr></tbody></table><ol><li>输入：单精度浮点数到小数点后六位时截断在此四舍五入，双精度浮点数也在小数点后六位截断但不进行四舍五入，若想改变精度，就再%之后添加0.n(n是需要的精确精确度)</li></ol><h2 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h2><table><thead><tr><th>格式符</th><th>含义（输出时）</th><th>输入时作用</th><th>示例（输出）</th></tr></thead><tbody><tr><td><code>%c</code></td><td>单个字符（<code>char</code>）</td><td>读取单个字符（包括空格、换行）</td><td><code>printf(&quot;%c&quot;, &#39;A&#39;);</code> → <code>A</code></td></tr><tr><td><code>%s</code></td><td>字符串（以<code>\0</code>结尾）</td><td>读取字符串（遇空格 &#x2F; 换行终止）</td><td><code>printf(&quot;%s&quot;, &quot;hello&quot;);</code> → <code>hello</code></td></tr></tbody></table><p>输入：输入字符串存的是缓存而非变量，因为字符串字符不止一个因此不像字符存在变量里，因为buf不像变量，buf是有地址的故没有取址符</p><p>在输入字符串时，出现异常<code>scanf_s</code> 是微软编译器提供的安全版本输入函数，对于字符串输入（<code>%s</code> 格式），<strong>必须显式指定缓冲区的大小</strong>作为第三个参数，否则会因参数不完整导致内存访问异常。</p><p>56:分</p><p>ffluysh(stdin);这个函数是用于清除第一次输入的回车键</p><p>scanf_s只输入空格前的字符串，gets函数会接受空格，认为这是一个字符串，为防止内存溢出，因此要在scanf_s函数后加上长度限制</p><h4 id="字符串输入：get与fgets"><a href="#字符串输入：get与fgets" class="headerlink" title="字符串输入：get与fgets"></a>字符串输入：get与fgets</h4><p>get(不安全)：风险：无法限制输入长度，若输入超过数组大小，会导致缓冲区溢出（覆盖其他内存）。</p><p>fgets:char *fgets(char *s, int size, FILE *stream);   </p><p>&#x2F;&#x2F; 从stream读取字符串，最多读size-1个字符（留1位存’\0’），遇换行或EOF停止 </p><p> &#x2F;&#x2F; 换行符会被保留在字符串中，最后添加’\0’</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>   <span class="hljs-comment">// 提供输入输出函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  <span class="hljs-comment">// 提供字符串处理函数（如strcspn）</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 定义足够大的字符数组（根据需求调整大小，这里用100）</span><br>    <span class="hljs-comment">// 注意：数组大小需 &gt;= 最大输入长度 + 1（用于存储字符串结束符&#x27;\0&#x27;）</span><br>    <span class="hljs-type">char</span> input_str[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-comment">// 2. 提示用户输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入字符串（可包含空格，最多99个字符）：&quot;</span>);<br><br>    <span class="hljs-comment">// 3. 使用fgets安全读取输入</span><br>    <span class="hljs-comment">// 参数说明：</span><br>    <span class="hljs-comment">// - input_str：存储字符串的数组</span><br>    <span class="hljs-comment">// - 100：最大读取长度（实际最多读99个字符，留1个位置给&#x27;\0&#x27;）</span><br>    <span class="hljs-comment">// - stdin：从标准输入（键盘）读取</span><br>    <span class="hljs-built_in">fgets</span>(input_str, <span class="hljs-number">100</span>, stdin);<br><br>    <span class="hljs-comment">// 4. 处理fgets遗留的换行符（若输入未超过最大长度，会包含&#x27;\n&#x27;）</span><br>    <span class="hljs-comment">// strcspn(input_str, &quot;\n&quot;) 查找第一个&#x27;\n&#x27;的位置</span><br>    input_str[<span class="hljs-built_in">strcspn</span>(input_str, <span class="hljs-string">&quot;\n&quot;</span>)] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 5. 输出验证输入结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你输入的字符串是：%s\n&quot;</span>, input_str);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这串代码可以正常运行</p><h3 id="stdin-stdout-stderr"><a href="#stdin-stdout-stderr" class="headerlink" title="stdin&#x2F;stdout&#x2F;stderr"></a>stdin&#x2F;stdout&#x2F;stderr</h3><ol><li>每个集成都有独立的内存空间，也拥有独立的fd句柄，程序启动时会打开三个流（文件）</li></ol><p>   stdin(标准输入，一般对应在键盘)，stdout(标准输出，一般对应屏幕)，stderr（标准错误输出。一般对应屏幕）。与stdin,stdout,stderr关联的整数形式的文件描述分别是0,1,2</p><p>   2.每个进程生来就有这三个文件描述符绑定在他们身上</p><p>   3.这三个文件可以重定向（比如从文件或者管道输入或者输出到文件），因此printf相当于fprintf(stdout,),scanf函数相当于fscanf(stdin)</p><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>1.输入变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123; <br>    <span class="hljs-type">char</span> c; <span class="hljs-comment">// 声明变量c</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input a:\n&quot;</span>);<br>    scanf_s(<span class="hljs-string">&quot;%c&quot;</span>, &amp;c, <span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %c\n&quot;</span>,c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br><br></code></pre></td></tr></table></figure><p>2.输入字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h.&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input string;\n&quot;</span>);<br>fgets(str,<span class="hljs-number">100</span>,<span class="hljs-built_in">stdin</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s,\n&quot;</span>,str);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>3.输入输出宽字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 包含标准输入输出头文件，提供基础的I/O函数（虽然这里主要用宽字符函数，但部分基础定义依赖此文件）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>   </span><br><span class="hljs-comment">// 包含宽字符操作头文件，提供宽字符相关的函数（如wprintf、宽字符串处理等）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wchar.h&gt;</span>  </span><br><span class="hljs-comment">// 包含本地化设置头文件，提供setlocale等函数，用于配置程序的区域设置（影响字符编码解析）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale.h&gt;</span> </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 设置程序的本地化环境：</span><br><span class="hljs-comment">     * - 第一个参数LC_ALL表示设置所有与本地化相关的类别（包括数字、时间、货币、字符编码等）</span><br><span class="hljs-comment">     * - 第二个参数&quot;&quot;表示使用系统默认的本地化配置（自动适配当前操作系统的语言和编码，如中文Windows的GBK、Linux的UTF-8等）</span><br><span class="hljs-comment">     * 作用：如果不设置，程序默认使用&quot;POSIX&quot;或&quot;C&quot; locale，不支持非ASCII字符（如中文），宽字符会显示为乱码</span><br><span class="hljs-comment">     */</span><br>    setlocale(LC_ALL, <span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 定义宽字符串：</span><br><span class="hljs-comment">     * - wchar_t是宽字符类型（通常占2或4字节，比char的1字节能表示更多字符，支持Unicode等大字符集）</span><br><span class="hljs-comment">     * - 字符串前加L前缀，表示这是一个宽字符常量（每个字符会被编译为wchar_t类型，而非char）</span><br><span class="hljs-comment">     * - 宽字符串本质是wchar_t类型的数组，以宽字符空终止符L&#x27;\0&#x27;结尾</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">wchar_t</span> *wide_str = <span class="hljs-string">L&quot;你好，这是宽字符串示例！&quot;</span>;  <span class="hljs-comment">// 宽字符串内容（包含中文等非ASCII字符）</span><br><br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 输出宽字符串：</span><br><span class="hljs-comment">     * - 使用wprintf函数（宽字符版本的printf），专门用于输出宽字符数据</span><br><span class="hljs-comment">     * - 格式字符串前加L前缀，表明这是宽字符格式串（与宽字符函数匹配）</span><br><span class="hljs-comment">     * - %ls是宽字符串的格式占位符（%s用于普通char字符串，%ls用于wchar_t宽字符串）</span><br><span class="hljs-comment">     * - 换行符\n在这里虽然是单字节，但宽字符函数会自动兼容基础控制字符</span><br><span class="hljs-comment">     */</span><br>    wprintf(<span class="hljs-string">L&quot;输出宽字符串：%ls\n&quot;</span>, wide_str);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.scan不安全，<strong>对输入长度缺乏边界检查</strong>。如果输入数据的长度超过缓冲区的实际大小，多余的数据会 “溢出” 到缓冲区之外的内存区域，覆盖其他变量甚至程序指令 scanf_s安全，但只能在Windows中用</p><p>5.4996是出现严重安全隐患的提示</p><ol start="6"><li></li></ol><p>gets 是已被弃用的不安全函数，因无边界检查导致缓冲区溢出风险，绝对禁止在实际开发中使用。</p><p>gets_s 是C11标准定义的安全替代函数，通过强制指定缓冲区大小解决溢出问题，但受限于编译器实现，跨平台兼容性较差（主要在 Windows 可用）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/25/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E4%B8%8E%E5%AE%9A%E4%B9%89/"/>
    <url>/2025/10/25/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E4%B8%8E%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="变量命名与定义"><a href="#变量命名与定义" class="headerlink" title="变量命名与定义"></a>变量命名与定义</h1><h2 id="定义"><a href="#定义" class="headerlink" title="# 定义"></a># 定义</h2><p> 变量是内存或寄存器中用一个标识符命名的储存单元，可以用来储存特定类型的数据并且数据的值并且在运行过程中可以进行修改</p><p>2.变量的地址：系统为变量在内存中分配的若干内存的首地址</p><p>变量的值：是变量在内存中所分配的内存单元中的数据</p><h1 id="变量的命名原则"><a href="#变量的命名原则" class="headerlink" title="## 变量的命名原则"></a>## 变量的命名原则</h1><p>1.只能有下划线，数字，字母组成，但第一个字符不能为数字，且字幕的大小写是不同的变量名，大写字母一般用作字符常量</p><p>2.变量名不能与特殊用途的关键字同名</p><p>3.变量或函数名应该足够长，且因该用英语 ，方便别人理解，且一般会对变量名的前31位，进行唯一性检查</p><p>   补充：唯一性检查  ：在编程中，变量名和函数名（统称为 “标识符”）的唯一性检查是确保程序逻辑正确、避免命名冲突的重要机制。其核心原则是：<strong>在同一作用域内，标识符必须唯一</strong>；不同作用域中允许同名（称为 “标识符遮蔽”）。</p><ol start="4"><li><p>局部变量，使用段名字，全局变量用较长的名字</p></li><li><p>windows命名规则：匈牙利法则</p></li><li><p>Linux：下划线命名：一般表识符和函数不推荐的大小写混用，只有小写字母，数字和下划线</p><h1 id="作业"><a href="#作业" class="headerlink" title="### 作业"></a>### 作业</h1><p><img src="/images/%E4%BD%9C%E4%B8%9A.png" alt="图片描述"></p><p>‘’’#include &lt;stdio.h&gt;</p><p>int main()</p><p>{</p><p>int a &#x3D;10;</p><p> printf(“地址：%p\n”,&amp;a);</p><p>return (0);</p><p>}</p></li></ol><p>​     %P是专门用于打印地址的格式说明符，&amp;是取值址符&amp;a表示a的地址</p><p>输出结果：地址：000000BEB7AFFBC4  </p><p>f代表该浮点数类型为单精度浮点数</p><p>第一个不对，变量名中不可以数字开头</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10.25</title>
    <link href="/2025/10/25/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E5%82%A8%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2025/10/25/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E5%82%A8%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<ul><li></li></ul><h1 id="变量的作用域，储存空间，生命周期"><a href="#变量的作用域，储存空间，生命周期" class="headerlink" title="变量的作用域，储存空间，生命周期"></a>变量的作用域，储存空间，生命周期</h1><p>#系统内存x86内存逻辑地址划分</p><table><thead><tr><th>内核空间</th><th>0xffffffff–0x7fffffff</th><th>只读</th><th>公有</th><th></th><th></th></tr></thead><tbody><tr><td>64kb非法空间</td><td>0x7fffffff–0x7fff0000</td><td></td><td></td><td></td><td></td></tr><tr><td>进程空间</td><td>0x7fff0000–0x0000ffff</td><td>私有，每个进程是相互隔离的</td><td>不可互相传递</td><td></td><td></td></tr><tr><td>64kb  null空间</td><td>0x0000ffff–0x00000000</td><td>不可访问</td><td></td><td></td><td></td></tr></tbody></table><!--x86支持32位因此虚拟内存空间最大为2^32=4GB--><p>1.进程空间布局</p><table><thead><tr><th>栈（tsack） 增长方向与内存相反</th><th>自动分配空间，存局部变量，函数参数，函数返回地址</th><th>内存方向由低到高</th></tr></thead><tbody><tr><td>空闲区</td><td></td><td></td></tr><tr><td>堆（非连续区域）(heap)</td><td>可以手动分配内存</td><td></td></tr><tr><td>代码区（code）</td><td>放代码</td><td></td></tr><tr><td>静态区（.data&#x2F;.bss&#x2F;.rdata）</td><td>存全局变量，静态变量手动分配（malloc&#x2F;new）和释放（free&#x2F;delet）</td><td></td></tr></tbody></table><p>内存方向：.rdata 只读字段存放常量，字符常量，const常量</p><p>​                  .data  :存放已经初始化好的全局变量和静态变量</p><p>​                 .bss：存放未初始化的全局变量合静态变量</p><p>​                   text 代码段：放置代码的</p><p>​                </p><p>补充：在编程中，<strong>初始化（Initialization）</strong> 指的是在创建变量、对象、数据结构或内存空间时，为其赋予初始值的过程。其核心目的是避免使用未定义的 “垃圾值”（随机或残留数据），确保程序行为可预测、数据状态一致。</p><p>1.因为栈的增长方向是向下增长的因此在数据过大的情况下会出现栈溢出，会破坏其他进程的数据2.</p><p>2.栈的大小</p><p>windows 应用栈：默认为1m 可以用&#x2F;stack改设其他值</p><p>内核栈：根据cpu加构而定，x86为12kb x64为24kb  安腾为32kb  因为其内存太小因此不能用递归函数，以防栈溢出</p><p>linux内核栈：4k   或 8k</p><p>应用栈：10m，可以通过ulimit -s查看和设置</p><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><h2 id="1-变量分类"><a href="#1-变量分类" class="headerlink" title="1.变量分类"></a>1.变量分类</h2><p>​         全局变量：全局变量说明位置在所有函数之外，整个程序可见，申明周期为整个程序运行期间，存储位置为静态存储区，若要在其他源文件中使用该全局变量要加上extern int 全局变量名</p><p>​        全局静态变量：与全局变量的区别在 于作用域 是在当前源文件，别的文件不能访问该变量 ，限制在源文件中是为了防止多个源文件         的命令冲突    基本格式为static int变量名 </p><p>​        局部变量：在函数内部说明的变量，只有在执行函数时局部变量才存在，作用域喜爱函数内部，存储空间为栈</p><p>​局部静态变量：与局部变量区别在于存在静态区， 整个程序运行期间，有记忆功能，能保留上次函数调用时的修改  ，只初始化一次</p><p>​       寄存器变量：在cpu中的寄存器中暂存数据,<code>register</code> 修饰的变量建议存储在寄存器（速度更快），但：不能取地址（<code>&amp;register_var</code> 错误）,仅适用于局部变量（全局变量不可用）。</p><p>作用域：在哪里可以访问这个变量</p><table><thead><tr><th>类型</th><th>作用域</th><th>存储空间</th><th>生命周期</th></tr></thead><tbody><tr><td>全局变量</td><td>整个程序课件</td><td>静态区</td><td>整个程序运行期间</td></tr><tr><td>全局静态变量</td><td>当前源文件</td><td>静态区</td><td>整个程序运行期间</td></tr><tr><td>局部变量</td><td>函数内部</td><td>栈</td><td>函数运行期间</td></tr><tr><td>局部静态变量</td><td>函数内部</td><td>静态区</td><td>整个程序运行期间</td></tr><tr><td>寄存器变量</td><td>函数内部</td><td>寄存器</td><td>函数运行期间</td></tr></tbody></table><p><img src="/images/%E4%BD%9C%E4%B8%9A2.png" alt="作业"></p><p>作业</p><p>1.代码输出的是毫无意义的垃圾值0，因为是未定义行为，%d是格式控制符，用于指定int整型以十进制输出</p><p>2.三者都是进程空间的一部分，静态区用于储存全局变量，静态变量，程序编译好后就分配好内存，直至程序结束才释放</p><p>栈存储局部变量和函数参数，使用时临时分配内存，函数跑完就自动释放，数据太大容易栈溢出</p><p>堆需要程序员手动申请空间且用完即释放，不然站着内存不放</p><p>3.全局变量：a（已初始化） p1（未初始化）a作用域使整个程序p1的作用域是当前源文件，存储空间是静态区，程序不停生命不止</p><p>b 为局部变量，存在栈例，作用域是函数内部，生命周期是func的运行期间</p><p>i为寄存器变量，作用域是函数内部，存储在寄存器内</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十月二十五日日志</title>
    <link href="/2025/10/25/10.25/"/>
    <url>/2025/10/25/10.25/</url>
    
    <content type="html"><![CDATA[<h1 id="变量命名与定义"><a href="#变量命名与定义" class="headerlink" title="变量命名与定义"></a>变量命名与定义</h1><h2 id="定义"><a href="#定义" class="headerlink" title="# 定义"></a># 定义</h2><p> 变量是内存或寄存器中用一个标识符命名的储存单元，可以用来储存特定类型的数据并且数据的值并且在运行过程中可以进行修改</p><p>2.变量的地址：系统为变量在内存中分配的若干内存的首地址</p><p>变量的值：是变量在内存中所分配的内存单元中的数据</p><h1 id="变量的命名原则"><a href="#变量的命名原则" class="headerlink" title="## 变量的命名原则"></a>## 变量的命名原则</h1><p>1.只能有下划线，数字，字母组成，但第一个字符不能为数字，且字幕的大小写是不同的变量名，大写字母一般用作字符常量</p><p>2.变量名不能与特殊用途的关键字同名</p><p>3.变量或函数名应该足够长，且因该用英语 ，方便别人理解，且一般会对变量名的前31位，进行唯一性检查</p><p>   补充：唯一性检查  ：在编程中，变量名和函数名（统称为 “标识符”）的唯一性检查是确保程序逻辑正确、避免命名冲突的重要机制。其核心原则是：<strong>在同一作用域内，标识符必须唯一</strong>；不同作用域中允许同名（称为 “标识符遮蔽”）。</p><ol start="4"><li><p>局部变量，使用段名字，全局变量用较长的名字</p></li><li><p>windows命名规则：匈牙利法则<br><img src="/images/%E5%8C%88%E7%89%99%E5%88%A9%E6%B3%95%E5%88%99.png" alt="匈牙利法则"></p></li><li><p>Linux：下划线命名：一般表识符和函数不推荐的大小写混用，只有小写字母，数字和下划线</p><h1 id="作业"><a href="#作业" class="headerlink" title="### 作业"></a>### 作业</h1><p>!(作业)(作业.png)(C:\Users\legion\Pictures\Screenshots\屏幕截图 2025-10-25 110402.png)</p><p>‘’’#include &lt;stdio.h&gt;</p><p>int main()</p><p>{</p><p>int a &#x3D;10;</p><p> printf(“地址：%p\n”,&amp;a);</p><p>return (0);</p><p>}</p></li></ol><p>​     %P是专门用于打印地址的格式说明符，&amp;是取值址符&amp;a表示a的地址</p><p>输出结果：地址：000000BEB7AFFBC4  </p><p>f代表该浮点数类型为单精度浮点数</p><p>第一个不对，变量名中不可以数字开头</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/24/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/10.24/"/>
    <url>/2025/10/24/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/10.24/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十月十八日日志</title>
    <link href="/2025/10/11/10.18/"/>
    <url>/2025/10/11/10.18/</url>
    
    <content type="html"><![CDATA[<ol><li><p>exe文件产生过程<br>源文件:a.c经过编译变成.obj文件再经过与lib(库文件)的链接最终变成.exe文件</p></li><li><p>pe格式<br>一种规范和标准，包含程序执行的代码，数据和资源<br>win:  exe. dll. sys.<br>linux:elf<br>等文件都属于pe格式的范畴<br>A. PE文件的格式<br>  ！<a href="pe%E6%A0%BC%E5%BC%8F.png">结构图</a><br>   a. DOS部首名为：MZ即e_magic<br>二进制代码查看部首对应值为“Ox5a4d”,其中”4d”代表M”5a”代表“z”<br>DOSStub:一串字符串。Win32 和x64并不能运行DOS<br>   b.pe文件头<br>以pe\0\0开头<br>在image_optional_header32的数据目录表中存有该PE文件的导入表和导出表（包含所调用的函数名称和地址等等）<br>   c.块表：记录每一个块(section)的所在位置<br>   d.块（section）：并不固定程序在编译和链接过程中，编译器会将代码和数据按照 “类型” 分配到不section 中，链接器再通过这些 section 组织最终的可执行文件。常见的默认 section 包括：<br>.text：存放可执行代码（函数体），通常是只读的。<br>.data：存放已初始化的全局变量或静态变量（非零值）。<br>.bss：存放未初始化的全局变量或静态变量（默认值为 0），仅占符号表空间，不占用实际文件大小。<br>.rodata：存放只读数据（如字符串常量）。<br>.stack：栈空间（运行时动态分配，不存放在目标文件中）。<br>.heap：堆空间（运行时动态分配，不存放在目标文件中）。<br>   e.调试信息：区别于release<br>重要概念：<br>  EOP：程序指令入口点即第一条指令的入口点<br>  OEP:原入口点，壳里的概念。加如壳之后入口点会变化，但执行过程中代码还会在原入口点执行即OEP<br>  EPO模糊，病毒概念，病毒在EOP中感染，会用到EPOA的技术<br>  壳：“壳”（Shell）通常指加壳技术（Packing），是一种对可执行文件（如 exe、elf、mach-o 等）进行保护的手段，目的是隐藏原始程序的代码逻辑，增加逆向分析的难度。<br>  imagebase:0x4000000(不修改情况下)指的是可执行文件（如 EXE、DLL 等 PE 格式文件）被操作系统加载到内存时的 “首选起始地址”。<br>  VA：虚拟地址（Virtual Address））采用 虚拟内存管理，程序不会直接操作物理内存（硬件实际的内存地址），而是通过 “虚拟地址” 间接访问。虚拟地址由操作系统和 CPU 的内存管理单元（MMU）转换为物理地址，对程序来说是 “透明” 的。<br>  RVA:RVA 是 相对虚拟地址（Relative Virtual Address） 的缩写，指的是相对于程序加载到内存的基地址（ImageBase）的偏移量。RVA &#x3D; VA - ImageBase<br>                    VA &#x3D; ImageBase + RVA<br>   voffset: 通常是 virtual offset（虚拟偏移量） 的缩写，指的是相对于某个具体虚拟地址（VA）的偏移量，用于描述内存中某一位置与另一个基准虚拟地址之间的距离。与 RVA（相对虚拟地址，相对于程序整体加载基地址 ImageBase 的偏移）不同，voffset 的 “基准” 更灵活 —— 它可以是任意一个虚拟地址（比如某个结构体的起始地址、某个节（section）的起始地址、某个函数的入口地址等），表示从这个基准 VA 开始向后偏移的字节数。<br>   roffset:通常是 relative offset（相对偏移量） 的缩写，指的是相对于某一特定基准地址（而非全局基准）的偏移量。它是一个更通用的概念，用于描述 “某位置与一个局部基准点之间的距离”。<br>工具了解pe<br>peid:能识别壳<br>REtool:<br> PID   ：在计算机领域，PID 特指 “进程 ID（Process ID）”，是操作系统（如 Windows、Linux、macOS 等）为每个正在运行的进程（程序的执行实例）分配的唯一数字编号。 </p><p>程序与进程和线程<br>a.程序<br>是存储在磁盘上的静态文件，由代码（指令）、数据（常量、变量定义）和相关资源（如配置、图标等）组成，是 “未执行的指令集合”。<br>特点：<br>静态存在：不占用 CPU、内存等系统资源，仅作为文件保存在存储介质（如硬盘）中。<br>可复用性：同一个程序可以被多次加载执行（例如多次双击 “记事本.exe”，会启动多个进程）。<br>b.进程是程序的一次动态执行过程，是操作系统进行资源分配（内存、CPU 时间片等）的基本单位。当用户运行一个程序时，操作系统会加载程序到内存，为其分配资源，并创建一个进程来管理执行过程。<br>特点：<br>动态生命周期：有创建（如双击程序）、运行、暂停、终止（如关闭窗口）等状态。<br>独立资源：每个进程拥有独立的内存空间（代码段、数据段、堆、栈），进程间的内存相互隔离（默认不可直接访问）。<br>系统开销较大：进程切换（如 CPU 从一个进程切换到另一个）需要保存和恢复整个进程的上下文（内存状态、寄存器等），开销较高。<br>c.线程是进程内的一个执行流，是 CPU 调度（分配 CPU 时间）的基本单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和资源（如代码段、全局变量、打开的文件句柄等），但每个线程有自己独立的栈（局部变量）和寄存器。  </p><p>第二课<br>C语言中的各个进制表达方法 </p><ol><li>八进制以0作为前缀</li><li>c语言中并没有单独二进制表示方法</li><li>16进制0-9，a-f，且以0x为前缀</li><li></li></ol><p>汇编语言中<br> 十六进制1aH<br> 八进制17o<br> 十进制12D<br> 二进制：110B<br>进制转换</p><ol><li>表格法十进制转二进制<br>1024   512  256  128  64  32  16  8  4  2  1<br>如47在32至64间  故在64下标0，在32下表1 ，47-32 &#x3D;15故16下标08下标1，以此内推<br>若要以1个字节为8位故47应该表达为00101111，若为2字节则在前添0直至16位<br>若有小数则用同样方法，只不过在表格右边加上2的-1，-2，-3…次方，在整数和小数连接处以’.‘连接</li><li>二进制转十六进制<br>十六进制每一位对应二进制四位如47 二进制为00101111，分组，1111转化为F，0010变为2，合起来47十六进制为2f<br>十六进制特点<br>十六进制1位对应二进制4位，故2位对应一个字节，能直接观察这个数在内存中每个字节的内容，一位占4bite</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十月二十日日志</title>
    <link href="/2025/10/11/10.20/"/>
    <url>/2025/10/11/10.20/</url>
    
    <content type="html"><![CDATA[<p>浮点数阶码问题<br>FLOAT：E&#x3D; e+127<br>Double:E&#x3D; e+1023</p><p>阶码E为了方便比较，为无符号数0单精度八位：范围1<del>154，双精度11位，范围1</del>2046，表示了一个规格化的非零浮点数</p><p>阶码全为0，尾数全为0，表示0<br>阶码全是1，尾数全是0，表示正无穷或负无穷<br>阶码为0而尾数非0时，给出NaN非数</p><p>真正的指数为阶码减去127&#x2F;1023<br>由于阶码可能为正数或负数（如表示很小的数时阶码为负），计算机中通常用移码（Offset Binary）表示阶码，而非原码或补码，原因是移码的大小可直接反映阶码真值的大小，方便浮点数比较（如加减运算中的 “对阶” 操作）。</p><p>移码 &#x3D; 阶码真值 + 偏移量（Bias）<br>单精度浮点数的偏移量为127<br>双精度浮点数偏移量为1023</p><p>C语言数据类型—–内建型别</p><ol><li>字符型：char &#x2F; wchar_t<br>  char占一个字节<br>  wchar_t占2或4个字节，宽字符类型  ，字节数与字符数不同，不慎会导致严重后果<br>char c &#x3D;  ‘a’这是常量字符  若要表示单引号字符应该如此表示’&#39; ‘<br>wchar_t wc &#x3D;L’ c ‘           L表示unicode编码ASCii编码，unicode存储空间<br>字符也分有无符号<br>在char前标signed有符号unsiand是无符号，如果不标signed或signed有无符号由编译器决定<br> 例如windos vs 开发环境中看做有符号</li><li>字符编码<br>存饭字符要通过编码才能储存类比学号<br>ASCII编码用一个字节表示编码因此表示编码不多<br>unicode编码，通常采用2个或4个字节表示一个字符UTF-8占1-4字节<br>                                     UTF-16占2个<br>                                     utf-32占4个字节<br> 如果数字被打上引号则是字符类型应该参照 ascii编码表，如果不加引号就是整数<br> 字符整数相互转换<br> 字符转整数：字符-‘0 ‘<br> 整数转字符：整数+’ 0’<br> 大小写转换<br> 例如：char c &#x3D;’M’<br> c + ‘  a’-‘A’;&#x2F;&#x2F;大写转小写<br> char ch &#x3D;’ y’;<br> c+’A’-‘a’&#x2F;&#x2F;小写转大写</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十月二十一 日日志</title>
    <link href="/2025/10/11/10.21/"/>
    <url>/2025/10/11/10.21/</url>
    
    <content type="html"><![CDATA[<ol><li>整型<br> short int 简写为short 短整型   2字节<br> int 标准整型    四字节<br> float 4<br> char 2<br> long  win x86,x64为4    linux x86 为4 x64为8<br> float 4<br> double 8<br> bool 4<br> BOOL 4</li></ol><p>typedef:定义函数类比于import …as…<br>typedf 就函数名  新函数名</p><ol start="2"><li>C语言数据长度和取值范围<br> 例如想分配100个char长度  不要写100<em>1（硬编码，失去可移植性），而要写100</em>sizeof（char）为了防止平台改变造成长度变化带来的后果</li></ol><p>  sizeof计算类型或者变量长度，字节为单位，是操作符，不是函数。在编译阶段确定而不是运行阶段</p><ol start="3"><li>各个类型表示的数的范围<br>n位无符号表示范围：[0,2^n-1]<br>n位有符号数范围[-2^(n-1),2^(n-1)-1]<br>如果整数超出该类型的范围则会溢出<br>char 有符号范围[-128,127]  无符号范围[0,255]<br>short    有符号范围   [-32768,32767]   无符号范围     [0,65535]<br>最值表示<br>无符号<br>unsigned max &#x3D;-1;&#x2F;&#x2F;1111111111111111<br>usigned int min &#x3D; 0<br>有符号<br>int max ox7fffffff;&#x2F;&#x2F;0111 1111 1111 1111<br>int min 0x0000000;&#x2F;&#x2F;1000 0000 0000 0000<br>无符号<br>unsigned char max &#x3D;-1&#x2F;&#x2F;11111111<br>uunsigned char min &#x3D;0<br>有符号<br>char max &#x3D;0x7f ;&#x2F;&#x2F;0111 1111<br>char min &#x3D;0x80;&#x2F;&#x2F;1000 0000</li></ol><p>整数溢出的后果<br>例如：(char)(-128*-1),-128*-1&#x3D;128二进制为10000000,取反加一，得到10000000，但这是绝对值，整数溢出，因此绝对值128在char中是-128<br>以此内推可得结论：上溢出一变成最小值<br>                下溢出一变成最大值<br>注：无论有误符号都遵循该结论<br>例[-128,127],127+1 &#x3D;-128<br>  [0,255],255+1 &#x3D;0</p><p>典型问题如千年虫或是UNIX 2038年问题</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十月十九日日志</title>
    <link href="/2025/10/11/10.19/"/>
    <url>/2025/10/11/10.19/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Bit最小单位<br>byte：字节大B   1byte&#x3D;bit<br>1Bit 仅能存储2个信息<br>1byte能存储2^8个信息</p></li><li><p>数据存储在寄存器，内存或磁盘中</p></li><li><p>整数的正负表示<br>a.有符号数<br>  最高位作符号位1表示负数，0表示正数，<br>b.无符号数：表示0和正数，无需表示正负，参与数字计算<br>只能是0-255</p></li><li><p>整数的编码<br>  原码，反码，补码<br>  a. 原码：与有符号数一样，符号位无法参加运算，例如十进制1-1&#x3D;0，用原码表示则是00000001+10000001得到结果10000010（十进制的-2）所以不用其作为整数编码<br>  b.反码：正数的反码：与原码（符号位 + 数值位的二进制表示）完全相同。<br> 负数的反码：符号位保持不变（仍为 1），其余数值位按位取反（0 变 1，1 变 0）。</p></li></ol><p>  c.补码 正数的补码就是原码<br>   负数的补码是其反码（将0改为1，将1改为0）加一，如-1补码为：11111111<br>    想求负数的绝对值就再取反+1<br>    0的补码还是0<br>    范围：-128————127<br>    再添加字字节时用符号位（正数是0，负数是1）</p><ol start="5"><li>整数的存储方式<br> 在十六进制数0x12 34 56  78  中12，被称为高位（高字节）78被称为地位（低字节）<br> 存储方式：低位优先即低位在低地址<br>    即78  56  34   12（十六进制的一位数字占2bit,两位数字占1byte故两位数字为一整体）<br> 高位存储：高位优先12 34 56 78高位放在低地址<br>  X86系统适用的是低位优先（intel &#x2F;window）<br> 例：0x00 00 00 01<br> 低位优先：01 00 00 00   little_endian<br> 高位优先：00 00 00 01   big_endian<br> ip数据报头使用网络字节序即高位优先</li></ol><p>浮点数定义和储存<br>定义：1.单精度浮点数：float，占4个字节<br>      2.双精度浮点数：double,占8个字节<br>      双精度比单精度精确<br>   例如<br>   float x &#x3D; 1.732f;          单精度<br>   double y - 3.1415926;      双精度<br>   加F就是单精度，不加就是双精度</p><p>浮点数的存储<br>a. 科学计数法<br>  二进制科学计数法类比十进制如<br>  1011.0 &#x3D; 1.01101*2^3,1.01101为尾数，3为指数，0为符号位（ 就是正负号）</p><p>  浮点数试讲特定长度的连续字节（4个或8字节）的所有二进制位（32位或64位）分割为三个域<br>  符号域    (S)  ，占1位，正数为0，负数为1<br>  阶码域：单精度中占8位，双进精度中占11位。对于单精度而言是指数+127，双精度是指数+1023，指数可能为正也能为负，不便与比较   阶码域为非负数便于比较<br>  尾数域（M）体现精度差别，单精度尾数共23位，双精度尾数有52位<br>       因为尾数都是1开头，所以可以不用储存，但使用时仍要带上1</p><pre><code class="hljs">   用于计算存储</code></pre><p>公式   V &#x3D; (-1)^s<em>M</em>2^e &#x3D;(-1)^S<em>M</em>2^(E-127)&#x2F;(E-1023)    e为指数   E为阶码<br>浮点数存储格式： 1符号位（0&#x2F;1）2.阶码（  二进制   指数+127&#x2F;1023  8位  ）  3. 尾数域(   M)浮点数的小数部分（二进制，补0至23位或48位）</p><p>M是浮点数转为二进制后的科学计数法小数部分再补0直到23位或是48位<br>阶码&#x3D;（指数+127&#x2F;1023）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十月二十二日日志</title>
    <link href="/2025/10/11/10.22/"/>
    <url>/2025/10/11/10.22/</url>
    
    <content type="html"><![CDATA[<ol><li><p>中学数学与计算机结合<br> 无符号数的范围实质上是公比为2，首相为1的等比数列的求和，根据求和公式a(1-q)^n&#x2F;(1-q)带入数据得到公式（10.21日志）[0,2^n-1]<br> 在有符号的情况下，正数部分因为有符号位所以比无符号的情况少一项故正数部分公式为2^(n-1)-1<br> 有符号的最小值要取反加一设最小值为n位，去除一位符号位剩下(n-1)位，所以最小值是-2^(n-1)<br> 综上所述：有符号的情况取值范围为[-2^(n-1),2^(n-1)-1]</p></li><li><p>c语言数据类型转换</p></li><li><p>强制转换：程序员主动进行转换在目标变量或常量前把目标形式用括号括起来形式  （新类型）变量<br>例：从小到大转换<br>char c &#x3D;’a’;#将ASCII编码a赋值给char c 此时c占一个字节<br>short i &#x3D;(short)c;#将c转型为short再赋值给i<br>int a&#x3D;(int) i;<br>unsigned int u &#x3D;(unsigned int) a#此时将a由有符号变为无符号，此时的符号位也参与计算<br>转化所导致的大小变化是临时的并不改变其原来变量大小，再赋值会将临时结果保存在新变量里<br>例2浮点数转化为整数,是取整并不四舍五入；<br>   int i &#x3D; (int)3.14;此时i就是3<br>例3. 从大到小可能会精度丢失<br>   int x &#x3D;0x12345678#<br>   short y &#x3D; (short)x                 #该16进制数共占4字节short只占2字节此时会丢失两字节精度，丢弃高位字节12 34<br>   在从小到大的转换时，用符号位填充多出的位数例如：00110101变大后应为 000000000 00110101</p><p>   short s &#x3D;-0x12;<br>   int i &#x3D;(int) s;&#x2F;&#x2F;i i&#x3D;0x ff ff ff ee十六进制先转二进制，再用符号位填充后再取反加一再变回十六进制</p></li><li><p>自动转换 （隐式转换）       </p><ol><li>如果参与运算量的类型不同，则先转换成同一类型再开始转换</li><li>转换数据按数据长度增长方向进行，以保证精度不降低。即全部转换成最长的类型<br>若两种数据的字节数相同，且一种有符号一种无符号则转化为无符号类型</li><li>所有浮点数都是以双精度进行的，既是只有单精度浮点数也要转换为双精度浮点数再运算（补充：在浮点数后面带有f的是单精度浮点数（float））</li><li>char 类型和short类型参与运算时必须先转换成int类型</li><li>在赋值运算时赋值号两边量的数据类型不同时，复制好的右边量的类型将转变为左边变量的类型。类型不一样可能会降低精度</li><li>算数转换也遵循以上原则</li><li>函数调用中参数传递时，系统隐式的将实参转化为形参的类型后，付给新参。char和short会被转换成int,float会被转换成double</li><li>printf 函数会将char,short转换成int,float会被转换成double传递</li><li>函数有返回值时，系统将隐式的返回表达式类型转换为返回值类型，赋值给函数<br>例如  int func()<br>{<br>return 3.14f;<br>}#此时返回值就会由浮点数变成整型</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>十月二十三日日志</title>
    <link href="/2025/10/11/10.23/"/>
    <url>/2025/10/11/10.23/</url>
    
    <content type="html"><![CDATA[<ol><li>Python中的逻辑运算符<ol><li><p>假值（Falsy）对象<br> Python 中明确被定义为假值的对象只有以下几类，其余所有对象均为真值：<br> 布尔值False本身<br> 空值None<br> 数值中的 “零”：<br> 整数0<br> 浮点数0.0、-0.0<br> 复数0j（实部和虚部均为 0）<br> 空的序列 &#x2F; 集合 &#x2F; 映射：<br> 空字符串’’、””<br> 空列表[]<br> 空元组()<br> 空字典{}<br> 空集合set()<br> 空范围对象range(0)（无元素的 range）<br> 自定义对象中，若定义了__bool__()方法且返回False，或定义了__len__()方法且返回0（优先判断__bool__）。</p></li><li><p>真值（Truthy）对象<br> 除上述假值外的所有对象均为真值，典型例子：</p></li><li><p>逻辑运算符<br>and    逻辑与    全为真则真，有一假则假    遇第一个假值则返回，不再计算    最后被求值的操作数<br>or    逻辑或    有一真则真，全为假则假    遇第一个真值则返回，不再计算    最后被求值的操作数<br>not    逻辑非    对真 &#x2F; 假取反    无（仅单操作数）    布尔值（True&#x2F;False）</p></li><li><p>位运算符</p></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux基础命令</title>
    <link href="/2025/10/11/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/10/11/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>在Linux中一切皆为文件，文件夹名为目录。Linux的命令是模块化的通过空格来体现模块，故在使用命令时要注意这一点<br>linux如何获取管理员权限<br>一.临时权限（低风险，但麻烦）命令：sudo apt update<br>二.永久权限：su  # 切换到root用户<br>            # 输入root用户的密码（若未设置root密码，可能需要先通过sudo设置）<br>            exit  # 回到普通用户<br>注意：1.安全风险：永久使用 root 权限可能因误操作（如删除系统文件）导致系统崩溃，建议优先使用sudo获取<br>        临时权限。<br>      2.root 密码：部分 Linux 发行版（如 Ubuntu）默认禁用 root 密码，需通过sudo passwd root设置 root 密码后才能使用su切换。<br>      3.权限回收：若要取消某个用户的sudo权限，可通过visudo删除对应配置行。</p><ol><li><p>cd（cd ~）：默认切换到当前用户的家目录<br>cd ..：切换到父目录,..表示当前目录的上一级目录（父目录）<br>cd .：切换到当前目录（无实际意义）<br>cd -：切换到上一次所在的目录<br>cd &#x2F;：切换到根目录</p></li><li><p>ls:查看当前目录下的文件和子目录<br>ls -a:查看更详细的目录<br>ls -l:以长格式显示文件 &#x2F; 目录的详细信息，每行代表一个文件 &#x2F; 目录，输出包含 7 个核心字<br>例如-rw-r–r–  1  user  group  1024  Oct 14 15:30  file.txt<br> 各字段含义：<br> 1.权限位（-rw-r–r–）：共 10 位<br> a.第 1 位：文件类型（-普通文件，d目录，l软链接，b块设备等）<br> b.后 9 位：权限（分 3 组，每组 3 位，分别对应所有者 u、所属组 g、其他用户 o的权限）r（读，4）、w（写，2）、x（执行，1）， -表示无权限<br>  ps.示例中：所有者有rw（读写），组用户和其他用户有r（只读）。<br> c.硬链接数（1）：文件被硬链接的次数（目录默认是 2，含.和..）。<br> d.所有者（user）：文件的所属用户。<br> e. 所属组（group）：文件的所属用户组。<br> f.大小（1024）：文件大小（单位字节，目录显示为 4096 等固定值）。<br> g.修改时间（Oct 14 15:30）：文件最后一次内容修改的时间。<br> h.文件名 &#x2F; 目录名（file.txt）：文件或目录的名称。</p></li><li><p>touch :创建文件<br>touch  file1 file2 file3:创建三个文件<br>touch &#x2F;目录&#x2F;文件名：在指定目录中创建文件</p></li><li><p>cat :查看文件内容<br>cat file1 file2 file3:查看多个文件<br>cat &gt; [新文件名]：创建新文件并写入内容,ctrl+d建是退出编辑模式<br>cat &gt;&gt; [文件名]：向已有文件追加内容<br>cat [文件1] [文件2] &gt; [目标文件]：合并多个文件到新文件</p></li><li><p>管道符（|）的使用<br>管道符用于将前一个命令的输出作为后一个命令的输入，实现命令组合。<br>格式：命令1 | 命令2<br>例如<br><img src="/%E4%BE%8B%E5%AD%901.png" alt="先用ls将桌面上的文件全列举出来，再用greb命令将其中带有txt的筛出来"></p></li><li><p>mv 如何重命名文件 mv 命令本质是 “移动文件”，当源文件和目标路径在同一目录时，就是 “重命名”。<br>格式：mv .&#x2F;现在目录的子目录，目标文件的父目录（有点拗口）&#x2F;目标文件 .&#x2F;同上&#x2F;目的地<br>！<a href="%E4%BE%8B%E5%AD%902.png">例3</a></p></li><li><p>ln -s:软连接，旨在简化路径，其用途类似于Python中import 模块名 as 别名<br>注意：若源文件移动位置，软连接会失效，需重新创建。<br>例：ln -s &#x2F;home&#x2F;cjy&#x2F;桌面&#x2F;b.txt  toc  #将b.txt文件简称为toc</p></li><li><p>cp:复制文件</p><h1 id="复制当前目录的-note-txt-到-home-user-backup-目录下"><a href="#复制当前目录的-note-txt-到-home-user-backup-目录下" class="headerlink" title="复制当前目录的 note.txt 到 &#x2F;home&#x2F;user&#x2F;backup 目录下"></a>复制当前目录的 note.txt 到 &#x2F;home&#x2F;user&#x2F;backup 目录下</h1><p>cp note.txt &#x2F;home&#x2F;user&#x2F;backup&#x2F;</p><h1 id="复制文件并在目标位置重命名（若目标是新文件名）"><a href="#复制文件并在目标位置重命名（若目标是新文件名）" class="headerlink" title="复制文件并在目标位置重命名（若目标是新文件名）"></a>复制文件并在目标位置重命名（若目标是新文件名）</h1><p>cp data.csv &#x2F;tmp&#x2F;archive&#x2F;data_backup.csv</p><p>注：复制目录需加 -r（递归）：cp -r .&#x2F;docs &#x2F;mnt&#x2F;usb&#x2F;</p></li><li><p>绝对路径和相对路径<br>   绝对路径：从根目录（&#x2F;）开始的完整路径，唯一确定文件位置。<br>   示例：&#x2F;home&#x2F;user&#x2F;downloads&#x2F;file.zip、&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。<br>   相对路径：相对于当前所在目录的路径，依赖当前位置。<br>   符号：.&#x2F; 表示当前目录（可省略），..&#x2F; 表示上一级目录。</p></li></ol><p>   示例：<br>   若当前在 &#x2F;home&#x2F;user，则 .&#x2F;docs&#x2F;note.txt 等价于 docs&#x2F;note.txt（相对路径），对应绝对路径 &#x2F;home&#x2F; user&#x2F;docs&#x2F;note.txt。<br>   ..&#x2F;public&#x2F;index.html 表示 “上一级目录的 public 文件夹中的 index.html”。<br>11. 设置用户密码、root 密码及切换用户<br>    设置密码<br>    当前用户改密码：passwd（输入原密码，再输新密码）。<br>    管理员给其他用户设密码：sudo passwd 用户名（需 sudo 权限）。<br>    设置 root 密码（默认可能未启用）：sudo passwd root（输入当前用户密码，再设 root 新密码）。<br>    切换用户<br>    切换到普通用户：su - 用户名（- 表示加载目标用户的环境变量）。<br>    切换到 root 用户：su - root（需输入 root 密码）或 sudo -i（直接获取 root 环境，无需 root 密码，需当前用户在 sudoers 列表）。<br>    退出切换的用户：exit 或 Ctrl+D。<br>12. 文本编辑器的基本使用（写入、保存）<br>    简单编辑器 nano（推荐新手）<br>    打开 &#x2F; 创建文件：nano 文件名（如 nano test.txt）。<br>    写入内容：直接键盘输入即可。<br>    保存：按 Ctrl+O（提示确认文件名，回车确认）。<br>    退出：按 Ctrl+X。<br>13. 压缩文件<br>   a.tar命令<br>    压缩：tar -czf 压缩包名。tar.gz 源文件&#x2F;目录（此处指的是目标文件在压缩包的那个位置）<br>    解压：tar -xzf 压缩包名.tar.gz  # x&#x3D;解压，z&#x3D;gzip，f&#x3D;指定文件名<br>   b.zip格式<br>   压缩：zip 压缩包名.zip 文件1 文件2 目录<br>   解压：将zip改为unzip<br>14.  查看基本的日志文件<br>    cat &#x2F;var&#x2F;log&#x2F;syslog  # 查看全部内容（适合小文件）<br>   tail -n 20 &#x2F;var&#x2F;log&#x2F;auth.log  # 查看最后20行</p><p>   tail -f &#x2F;var&#x2F;log&#x2F;syslog  # 实时跟踪新增内容（按 Ctrl+C 退出）</p><ol start="13"><li><p>常用的二进制文件目录<br>&#x2F;bin：基本系统命令（如 ls、cp，所有用户可执行）。<br>&#x2F;sbin：系统管理命令（如 reboot、ifconfig，通常需 root 权限）。<br>&#x2F;usr&#x2F;bin：用户常用命令（如 python、git）。<br>&#x2F;usr&#x2F;sbin：用户系统管理命令（如 nginx、apache2）。<br>&#x2F;usr&#x2F;local&#x2F;bin：本地编译安装的程序（如手动安装的软件）。</p></li><li><p>给文件赋权（chmod）<br>  chmod 用于修改文件 &#x2F; 目录的读写执行权限：<br> 数字法（推荐）<br> 权限对应数字：r&#x3D;4，w&#x3D;2，x&#x3D;1，每组权限为 3 个数字之和（所有者 u、组 g、其他 o）。REAd&#x3D;r write &#x3D;w   execute(执行) &#x3D;x<br>  示例：<br> bash<br>  chmod 755 script.sh  # 所有者：rwx（7&#x3D;4+2+1），组和其他：rx（5&#x3D;4+1）<br>  chmod 644 note.txt   # 所有者：rw（6&#x3D;4+2），组和其他：r（4）</p></li><li><p>递归删除<br>删除目录及其所有子文件 &#x2F; 子目录，用 rm -r（r&#x3D; 递归），强制删除加 -f（不提示）。<br>示例：<br>bash<br>rm -r old_dir&#x2F;        # 删除 old_dir 及内容（会提示确认）<br>rm -rf temp&#x2F;          # 强制删除 temp 及内容</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2025/10/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/10/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>一  工具准备<br>    1.github账号注册（略）<br>    2.下载git<br>      在下载完成后鼠标右键 git bush here<br>      粘贴以下命令git config –global user.name “Your Name”<br>git config –global user.email “<a href="mailto:&#x65;&#x6d;&#97;&#x69;&#x6c;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">email@example.com</a>“<br>    3.下载node js<br>    下载完成后输入node -v和npm -v检查是否安装成功<br>二    创建仓库<br>  进入github网站中点击右上角的头像，再点击Your repositonries点击new按钮，创建自己的仓库填写自己的仓库名，格式为&lt;用户名&gt;.github.io，然后点击Create repository点击创建新文件创建一个新文件，作为我们网站的主页新文件的名字必须为index.html，内容随意，填写之后点击Commit new file提交，<br>四 hexo部署<br>  1.安装 Hexo</p><p>   npm install -g hexo-cli<br>  2.查看版本chhexo -v<br>  3.初始化<br>  hexo init hexo-blog<br>   cd hexo-blog<br>   npm install<br>  4.本地启动<br>   hexo g<br>   hexo server<br>  5.创建文章<br>    Hexo 博客目录中的 _config.yml，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。<br>    post_asset_folder: true<br>    执行如下命令创建一篇新文章，名为《测试文章》<br>    hexo new post 测试文章<br>    若要添加图片<br>      1.将hexo-blog文件夹拉入编辑器（如ws code中）打开post新建文件image<br>      2在image中加入图片<br>      3在目标文件中加入<img src="/images/jpg" alt="图片描述"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机搭建</title>
    <link href="/2025/10/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/10/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>一 准备工作<br>   1.下载vmwear<br>   2.访问<a href="https://mirrors.tuna.tsinghua.edu.cn/%EF%BC%88%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99%EF%BC%89">https://mirrors.tuna.tsinghua.edu.cn/（清华大学镜像网站）</a><br>   3.下载iso文件<br>二 具体操作<br>   1.点击创建虚拟机。选择自定义。<br>   2.选择稍后安装操作系统<br>   3.选择Linux操作系统<br>   4.更改磁盘<br>   5.一直跟着推荐走直至完成</p><p>ps:笔者在配置时出现以下报错<br>    Mware Workstation 不可恢复错误: (svga)</p><p>Exception 0xc0000005 (access violation) has occurred.</p><p>日志文件位于“D:\vmwear工具\vmweardata\Ubuntu 64 位 (2)\vmware.log”中。  </p><p>您可以请求支持。  </p><p>要收集数据提交给 VMware 技术支持，请选择“帮助”菜单中的“收集支持数据”。</p><p>也可以直接在 Workstation 文件夹中运行“vm-support”脚本。</p><p>我们将根据您的技术支持权利做出回应。</p><p>目前尚未找到解决方案</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/11/%E4%BD%A0%E5%A5%BD/"/>
    <url>/2025/10/11/%E4%BD%A0%E5%A5%BD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2025/10/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2025/10/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/_image/1.jpg" alt="图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
      <tag>示例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2025/10/11/Hello-Hexo/"/>
    <url>/2025/10/11/Hello-Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="这是文章正文"><a href="#这是文章正文" class="headerlink" title="这是文章正文"></a>这是文章正文</h1><p>这里可以使用 Markdown 语法编写内容，例如：</p><ul><li>列表项 1</li><li>列表项 2</li></ul><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>正文内容…</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/10/09/hello-world/"/>
    <url>/2025/10/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="/images/1.jpg" alt="图片描述"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
